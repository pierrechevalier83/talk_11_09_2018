<!DOCTYPE html>
<html>
  <head>
    <title>SAFE Network Presentation</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Vollkorn);
      @import url(https://fonts.googleapis.com/css?family=Monaco);
      @font-face {
          font-family: Halis Round;
          font-style: normal;
          font-weight: bold;
          src: url("assets/fonts/HalisR-Bold.otf") format("opentype");
      }
      @font-face {
          font-family: Campton;
          font-style: normal;
          font-weight: 600;
          src: url("assets/fonts/campton-semibold.ttf") format("truetype");
      }
      body {
        font-family: 'Volkorn';
        color: black;
        max-width: 90%;
      }
      h1, h2 {
        font-family: 'Halis Round';
        max-width: 95%;
      }
      h3 {
        font-family: 'Campton';
        max-width: 90%;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Monaco';
        width: 90%;
      }
      .classy_text {
        color: #333333;
        max-width: 90%;
      }
      .white_text {
        color: white;
        max-width: 90%;
      }
      .remark-code-line-highlighted {
         background-color: #373832;
      }
      .remark-code-span-highlighted {
         background-color: #f0572a;
      }
      .fitted-pic img {
        height: auto;
        width: auto;
        max-height: 340px;
        max-width: 80%;
      }
      .small-pic img {
        height: auto;
        width: auto;
        max-height: 100px;
        max-width: 350px;
      }
      .tiny-pic img {
        height: auto;
        width: auto;
        max-height: 35px;
        max-width: 35px;
      }
      .logo img {
        height: auto;
        width: auto;
        max-height: 35px;
        position: absolute;
        top: 8%;
        left: 1.7%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
name: title

class:center
.logo.left[![logo](assets/images/logo.svg)]
<br><br><br><br>

---
layout: true
name: textures
background-position: right bottom, 87.5% top, 75% bottom, 62.5% bottom, right top
background-size: 11.1% 85%, 11.1% 15%, 11.1% 33%, 11.1% 6%, 11.1% 15%  
background-repeat: repeat;

---
layout: true
name: textures_2
background-position: right top, 87.5% bottom, 62.5% top, right bottom, 50% top
background-size: 11.1% 56%, 11.1% 44%, 11.1% 16.25%, 11.1% 44%, 11.1% 6%  
background-repeat: repeat;

---
layout: true
name: textures_3
background-repeat: no-repeat
background-position: right top, 87.5% top, 75% bottom, left top, 12.5% bottom
background-size: 11.1% 100%, 11.1% 100%, 11.1% 16%, 11.1% 6%, 22.2% 6% 

---
layout: true
name: yellow
class: classy_text
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]<br>

---
layout: true
name: light_grey
class: classy_text
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]<br>

---
layout: true
name: dark_grey
class: white_text
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: red
class: white_text
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: blue
class: white_text
background-color: #1f3a80
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: sea
class: classy_text
template: textures
background-image: url("assets/images/texture_1.png"), url("assets/images/texture_3.png"), url("assets/images/texture_2.png"), url("assets/images/yellow.png"), url("assets/images/yellow.png")
background-color: #f5f4f2
<br><br><br>

---
layout: true
name: sea_2
class: classy_text
template: textures_2
background-image: url("assets/images/texture_1.png"), url("assets/images/texture_2.png"), url("assets/images/texture_3.png"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds
class: classy_text
template: textures_3
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_1
class: classy_text
template: textures_3
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_2
class: classy_text
template: textures
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/light_grey.svg"), url("assets/images/light_grey.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_3
class: classy_text
template: textures_2
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_4
class: classy_text
template: textures
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/light_grey.svg"), url("assets/images/light_grey.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: fields
class: white_text
template: textures
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/yellow.png"), url("assets/images/light_grey.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_2
class: white_text
template: textures_2
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/red.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_3
class: white_text
template: textures_3
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_4
class: white_text
template: textures
background-image: url("assets/images/texture_7.png"), url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks
class: white_text
template: textures
background-image: url("assets/images/texture_9.png"), url("assets/images/texture_10.png"), url("assets/images/spark-texture-1.jpg"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_2
class: white_text
template: textures_2
background-image: url("assets/images/spark-texture-1.jpg"), url("assets/images/spark-texture-3.jpg"), url("assets/images/texture_10.png"), url("assets/images/yellow.png"), url("assets/images/white.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_3
class: white_text
template: textures_3
background-image: url("assets/images/texture_9.png"), url("assets/images/texture_10.png"), url("assets/images/spark-texture-1.jpg"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_4
class: white_text
template: textures
background-image: url("assets/images/spark-texture-1.jpg"), url("assets/images/spark-texture-3.jpg"), url("assets/images/texture_10.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: art
background-position: bottom right
background-size: 40% 90%
background-repeat: repeat

---
layout:true
name:small_dots
class: white_text
template: art
background-image: url("assets/images/hiw_pattern_1.svg")
background-color: #1f3a80
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:ants
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_2.svg")
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:stripes
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_3.svg")
background-color: white
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:rain
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_4.svg")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:rings
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_5.svg")
background-color: white
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:the_end
class: classy_text
background-position: bottom
background-size: 100% 20%
background-repeat: repeat
background-image: url("assets/images/timeline_pattern_1.svg")
background-color: white
class:center
.logo.left[![logo](assets/images/logo.svg)]
<br><br><br><br>

---
template: sea
# PARSEC:
### Deep dive
<br><br><br>
.small-pic[![maidsafe](assets/images/logo.svg)]

--
count: false

???

---
template: sea_2

## Agenda
--
count: false
#### Consensus in the SAFE Network
--
count: false
#### PARSEC
--
count: false
 - ##### Gossip graph
--
count: false
 - ##### Meta-elections
--
count: false
 - ##### Binary consensus
--
count: false
 - ##### ABFT consensus
---
template: sparks

## Consensus in the SAFE Network

---
template:sparks_2
## Routing

### What it does
--
count: false
- Partitions the network into `sections`
???
- Sharding
- Decides which `nodes` belong in which `sections`
--
count: false
- Assigns a `close group` for each data
???

- Deduplication
- Redundancy
--
count: false
- Mitigates sybil attacks
???

- Node Ageing
- Node rellocation
--
count: false
- Allows secure communications across sections
???

- Secure message relay
--
count: false
- Enables consensus within a section
???

- Quorum of agreeing peers
- Agreement on events and orders
---
template:sparks_3
## Routing

### How it does it
--
count: false

- Pretend everything is a 256 bit int
---
template:sparks_3
count: false
## Routing

### How it does it

- Pretend **everything** is a 256 bit int

--
count: false
 - Computers
--
count: false
 - Data
---
template:sparks_4
## Routing

### How it does it

- Pretend everything is a **256 bit int**
--
count: false

```
Between 0 and 115792089237316195423570985008687907853269984665640564039457584007913129639935
```
???
 - 2<sup>256</sup>-1
 - ~10<sup>77</sup>
 - ~115 quattuorvigintillion
  - ~.1% of the number of atoms in the universe
--
count: false
can be represented in binary

```
0101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001
```
---
template:sparks
## Routing

### How it does it

- Reduce all problems to simple maths
--
count: false

 - Example: which section should this node join?
```
node id: 11010010001111100...
```
---
template:sparks
count: false
## Routing
### How it does it

 - Example: which section should this node join?
```
node id: 11010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | Right |       |       |
|      |       | 0     |       |       | 1     |       |       |
|      | Left  | Right |       |       | Left  | Right |       |
|      | 00    | 01    |       |       | 10    | 11    |       |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]

---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: `1`1010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | Right |       |
|      | 00    | 01    |       |       | 10    | 11    |       |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]
---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: 1`1`010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | **Right** |   |
|      | 00    | 01    |       |       | 10    | **11** |      |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]
---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: 11`0`10010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | **Right** |   |
|      | 00    | 01    |       |       | 10    | **11** |      |
| Left | Right | Left  | Right | Left  | Right | **Left** | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | **110**   | 111   |
]
---
template:sparks_2
## Routing

### How it does it

 - Example: who should store this data?
```
data id: 11010010001111100...
```
--
count: false
.center[The `GROUP_SIZE` closest<br>nodes in xor distance]
???
xor space has the desirable property that distances are unique
---
template:sparks
## Routing

### How it does it

 - Example: how do members of a section agree<br>
   on the order in which things happen?
--
count: false

.center.small-pic[![parsec](assets/images/byzantine_army.jpg)]
???
Byzantine Generals problem
---
template: fields_3
## The quest for consensus
.fitted-pic[![byzantine](assets/images/byzantine_army.jpg)]
???
In 1982, Leslie Lamport et all described the following mathematical problem:

A group of generals of the byzantine army are camped with their troops around an ennemy city. Communicating only by messenger, the generals must agree upon a common battle plan. However, one or more of them may be traitors trying to confuse the others.

The problem is to find an algorithm to ensure that the loyal generals will reach agreement.

This problem seems deceptively simple, but it has been extensively studied in the last 20 years and better and better solutions keep coming up.

---
template: fields_2
## The quest for consensus
### Our needs
<br>
--
count: false

- Asynchronous
???
We're speaking of a real world network hosted on people's computers.
We cannot make assumptions on the time it takes for a node to respond.
--
count: false
- Scalable
???
Optimal complexity: O(N*log(N))
--
count: false
- Permission-less
???
Can support dynamic membership: nodes die
--
count: false
- Open Source
???
GPL-v3
Necessary to fit within our ethos
--
count: false
- Simple
???
Simplicity is a property that is extremely underrated.
If an algorithm is simple, it improves the security of the implementation
as anyone can reason about it and see bugs.

---
template: fields
## The quest for consensus
### State of the art
#### Blockchain (2008)

* ~~Asynchronous~~
* ~~Scalable~~
* Permission-less
* Open Source
* Simple

---
template: fields_3
## The quest for consensus
### State of the art
#### HashGraph (2016)

* Asynchronous (*)
* Scalable
* Permission-less
* ~~Open Source~~
* Simple

---
template: fields_4
## The quest for consensus
### State of the art
#### Honey Badger BFT (2016)

* Asynchronous (*)
* Scalable
* Permission-less (*)
* Open Source
* ~~Simple~~

---
template: fields_2
## The quest for consensus
### State of the art
#### Avalanche (2018)

* ~~Asynchronous~~
* Scalable
* Permission-less
* Open Source
* Simple

---
template: fields
## The quest for consensus
.fitted-pic[![PARSEC](assets/images/falcon.png)]

???
So we came to realize that the state of the art wasn't enough and that we would need to come up with our own solution if we wanted a protocol to fit all our needs.

---
template:birds_2
## PARSEC
.fitted-pic[![PARSEC](assets/images/spoiler_alert.png)]

???
Now, how you solve a complex maths problem is by breaking it down into simpler maths problems and solving these.

Even better if someone else already solved these smaller maths problems for you so you can save some time.

In this section, I'll explain some of these smaller maths problems for the case of consensus.

It's gonna be really boring, so I thought I would reveal the features we gain from this exercise so hopefully that keeps you motivated to listen to my monotone lecture :) 
---
template:birds_2
count: false
## PARSEC
### Features
???
So with PARSEC, we achieved to find a solution to the Byzantine Generals Problem that is:
--
count: false

* Asynchronous ✓ (*)
???
Almost asynchronous:
- Every step of the algorithm is fully asynchronous with one exception: the concrete coin
- In that step, we can't claim we are fully asynchronous as we don't meet the technical theoretical requirements; although in practice, it's very unlikely to make a difference
- The synchrony assumption we have is still less than that of any competing protocol that scales like ours does
- We are currently focused on implementing the algorithm we already have as this is necessary to get the SAFE Network off the ground; but we think we may be able to make that last step fully asynchronous with no asterisque with a little bit more research
--
count: false
* Scalable ✓
???
No compromise: PARSEC can reach consensus in O(N*log(N)) which is at the theoretical limit for the number of nodes.
---
template:birds_2
count: false
## PARSEC
### Features
* Asynchronous ✓ (*)
* Scalable ✓
* Permission-less ✓
???
The algorithm can operate in a completely permission-less setting.
The only requirement is that less than a third of the participants at any time are malicious, which we guarentee in the SAFE Network with a number of Sybil protection measures such as node ageing.
Nodes can join a section and leave it without affecting consensus and without requiring any syncrhonous step.
--
count: false
* Open Source ✓
???
Not only in license, GPL-V3 which is Free software, but also in our ethos.
We have already received 2 contributions to the PARSEC github and feedback on the whitepaper from members of the forum and even from Vlad Zamfir from Ethereum.
--
count: false
* Simple ✓
???
In the litterature, you find all kinds of fancy algorithms to solve the Byzantine Generals Problem or parts of it; and most of them aren't even efficient.
Our algorithm only uses simple ideas and composes them to make an elegant solution.

Not to make it sound like we're some kinds of geniuses: the two most powerful, simple and elegant ideas behind PARSEC are the way we solve binary consensus and the concrete coin idea. Both ideas were shameless-ly ripped off from existing papers :D
---
template:birds
## PARSEC
.fitted-pic[![PARSEC overview](assets/images/parsec_overview.png)]
???
### In a nutshell

Before diving too deep into the details; let's cover PARSEC at a high level:

- Nodes on the network use gossip to communicate with each other.
Gossip is a very efficient way to communicate information in a trustless network.

- As they are gossiping to each other, each node keeps a full record of everything that has been gossiped to them. We call this record the gossip graph.

- The gossip graph is a data structure that is eventually consistent; which means that even though different nodes will build different gossip graphs, at some point nodes will have a proof that something that's in their graph will eventually make it to other nodes' graphs.

- What PARSEC does is infer an order on events that were communicated from the gossip graph

---
template:birds_3
## PARSEC
.fitted-pic[![Gossip](assets/images/gossip.jpg)]
???
### Gossip

Now when I said: nodes gossip to each other, this may seem a bit vague; but it's not.
The gossip protocol is a well known mathematical construct to spread information in distributed systems.

The idea is to spread information in a way that is totally resilient to any node being dishonest but also efficient.

- Broadcast: inefficient
O(N^2)
- Round Robin: not resilient
O(N)
- Gossip: pick partner at random every fixed time interval
O(N*log(N))

---
template:birds_2
## PARSEC
.fitted-pic[![Signatures](assets/images/signature.jpg)]
???
Gossiping information is enough to spread it in a resilient manner, but it's not enough to establish trust or to decide an order in which things happened on the network.

Nodes keep a record of everything that's been gossiped to them and they transmit that to other nodes when they're gossiping to them.

They do this with cryptograpically signed messages, which means that they can be proven to have propagated that version of the truth.

This means that if a node sent you a version of the truth and sent someone else a different version; this node would eventually be caught in their lie.

---
template:birds_2
## PARSEC
.fitted-pic[![Gossip-graph-0](assets/images/gossip_graph_0.svg)]
???
Let's dive in and see what a gossip graph may look like.

We will start by illustrating how a gossip graph may get generated and then we will use it to explain some related concepts.

We start by introducing our players. We have a network with four members, Alice, Bob, Carol and Dave. They start with nothing, but the situation will change soon.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-1](assets/images/gossip_graph_1.svg)]

???
Bob creates his first event (he observed something going on in the network).

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-2](assets/images/gossip_graph_2.svg)]

???
Bob gossips to Carol, which prompts her to create her own event. Note that she doesn't just store her event, but also the one she got from Bob.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-3](assets/images/gossip_graph_3.svg)]

???
Now Bob gossips to Alice, too.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-4](assets/images/gossip_graph_4.svg)]

???
Alice responds to Bob, so Bob creates another event.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-5](assets/images/gossip_graph_5.svg)]

???
In the meantime, Carol gossips to Dave.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-6](assets/images/gossip_graph_6.svg)]

???
...and to Alice.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-7](assets/images/gossip_graph_7.svg)]

???
Dave responds to Carol.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-8](assets/images/gossip_graph_8.svg)]

???
Carol gossips the event created by Dave's response to Bob.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-9](assets/images/gossip_graph_9.svg)]

???
Explain how there is some asynchrony going on - Bob sent gossip to Carol before he received new gossip from her, hence the other-parent is an older event.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-10](assets/images/gossip_graph_10.svg)]

???
Bob sends updated gossip to Alice.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-11](assets/images/gossip_graph_11.svg)]

???
Carol gossips to Dave.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-12](assets/images/gossip_graph_12.svg)]

???
Now let's name all the gossip events. We will call them by the first letter of creator's name and the sequence index, so Alice's events are a0, a1, a2..., Bob's are b0, b1,... etc. (Those are just arbitrary names to focus our attention when we talk about the graph.)

Note that since every time nodes gossip, they actually send everything they have, every node has _exactly_ all the ancestors of its latest event. Since the gossip events contain hashes of their parents, if two nodes have copies of the same single event, they are also guaranteed to have identical copies of all ancestors of this event. We say that their graphs are _consistent_.

By the way, this graph can't be a whole gossip graph stored by a single node, as there is no event that all other events are ancestors of. We should consider this illustration a "God's view", or just a part of a larger graph of a single node that contains some later events.

Also note that some of these gossip events could contain votes, which an observation by a node of something happening in the network. (The first event created by Bob probably does.)

---
template:birds_1
## PARSEC
.fitted-pic[![Seen-0](assets/images/seen_0.svg)]

???
Once we have the gossip graph, we can start talking about its properties. One of the important concept in such a graph is the concept of an event _seeing_ another event.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Seen-1](assets/images/seen_1.svg)]

???
Here is an example. We say that a1 _sees_ c0, because c0 is a1's ancestor. There is a caveat here - if a node was malicious and created a _fork_, and both branches of the fork contain ancestors of our event, then we say that it doesn't see any of them. This is an important protection against malicious behaviour - if you try to game the system, you lose all influence you might have had. We will expand on that in a moment.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Seen-2](assets/images/seen_2.svg)]

???
Another example: c2 sees b0. This is just to showcase that the event being seen doesn't have to be a direct ancestor of the event seeing it.

---
template:birds_2
## PARSEC
.fitted-pic[![Fork-0](assets/images/fork_0.svg)]

???
We mentioned forks before. In this example Carol is malicious and tried passing different information to different nodes. She created events c1 and c1' that both have c0 as the parent.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Fork-1](assets/images/fork_1.svg)]

???
Nothing special happens at first. Event d1 sees c1' normally.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Fork-2](assets/images/fork_2.svg)]

???
It is at d2 that interesting things happen. d2 has both c1 and c1' among its ancestors. Upon creation of this event, Dave will know that something fishy is happening. By the definition of seeing, even though d1 sees c1', d2 doesn't see either c1 or c1'. In fact, it and its descendants won't see any event created by Carol at all.

---
template:birds_1
## PARSEC

### Supermajority

> A supermajority is a subset of the network<br>
> containing more than 2/3 of the total number of nodes

???
Let us now introduce a notion that will be used quite a lot.

The notion of a majority is rather well known. Unfortunately, in the presence of malicious actors, who can constitute up to 1/3 of the network, we cannot rely on just a majority, as a significant portion of it might be the bad guys. Thus, we define something more: a supermajority, which is more than 2/3 of the network. It has two nice properties.

--
count:false
#### Properties
* A supermajority contains a majority of the honest nodes

???
First, a supermajority will always contain the majority of honest nodes. So whatever a supermajority says, we know that a majority of honest nodes agree.

--
count:false
* Two supermajorities _always_ have an honest node in common

???
Second, any two supermajorities are guaranteed to have an honest node in common. This second property is something that makes supermajorities a very useful concept.

Of course, we could get those two properties by requiring 100% of nodes in a supermajority - but then the malicious nodes could stop us from collecting one. In this case, as long as the malicious nodes constitute less than 1/3 of the network, we will be fine.

---
template:birds_2
## PARSEC
.fitted-pic[![Strongly-seen-0](assets/images/strongly_seen_0.svg)]

???
Another important concept is the one of _strongly seeing_. An event seeing another event can be thought of as a proof that the first event's creator has received the second event and that it wasn't aware of any forks by the second event's creator at that time. Strongly seeing provides something much stronger.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Strongly-seen-1](assets/images/strongly_seen_1.svg)]

???
To say that event A strongly sees event B, we need event A to see events created by a supermajority of nodes that all see B.

Another possible wording of strongly seeing is: A strongly sees B if there are directed paths from B to A that together pass through events created by a supermajority of nodes. Note that the initial and final events count, too.

In this example a1 strongly sees b0. It sees itself (a1), c0 and b0 itself, all of which see b0. These events are created by Alice, Bob and Carol, so 3 nodes, which are more than 2/3 out of 4.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Strongly-seen-2](assets/images/strongly_seen_2.svg)]

???
Let's look at another example. We have d1 seeing c2, b1 and a0. Those are events by 4 different creators that all see a0. Thus, d1 strongly sees a0.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Strongly-seen-3](assets/images/strongly_seen_3.svg)]

???
In this example we look at a2 and a0. The only events seeing a0 that a2 sees are events created by Alice and Bob. These are just 2 out of 4, so not a supermajority, so a2 doesn't strongly see a0.

The reason strongly seeing is so important is because it provides a strong guarantee: if an event strongly sees an event created by node X, no other event can strongly see an event created by X that is on another branch of a fork.

---
template:birds_1
## PARSEC

### Strongly seeing

> If event `x` strongly sees event `y`, no other event<br>
> can strongly see any event by `y`'s creator that is<br>
> on a different branch of a fork.

???
Assume they could.

Assume Carol created a fork, and an event by Alice strongly sees event cn, and an event by Bob strongly sees cn'. This means that Alice's event sees events by a supermajority of creators that see cn. Bob's event sees events by a supermajority of creators that see cn'.

---
template:birds_1
count:false
## PARSEC

### Strongly seeing

> If event `x` strongly sees event `y`, no other event<br>
> can strongly see any event by `y`'s creator that is<br>
> on a different branch of a fork.

???
The supermajorities must have an honest node in common - say Dave. Dave would have to have created an event that sees cn and an event that sees cn'. But Dave is honest, so one of those is an ancestor of the other. Say d4 sees cn', and d3 (ancestor of d4) sees cn.

This means that cn is also an ancestor of d4. But by definition of seeing, it follows that d4 can't see either cn or cn', because both branches of the fork contain one of its ancestors. This is a contradiction, because we assumed that d4 sees cn'.

---
template:birds_2
## PARSEC
.fitted-pic[![Interesting](assets/images/interesting_event.svg)]
???
Now, as we mentioned when describing gossip graphs, some of the events contain votes from nodes.

For instance Alice may learn that Eric would like to join the network and then vote for this.

We could reach consensus on the order of any one of these votes, and that would totally work; but for us, in the SAFE Network, we only care about votes that have reached quorum. So in our case, we will only be interested in events that **see** **gossip events** containing **votes** for a given **network event** created by a supermajority of nodes.

But our case is just our case - other users of PARSEC may define interesting events differently. What matters is that some of the events are interesting and this is the starting point for the rest of the algorithm.

---
template:birds_1
## PARSEC
.fitted-pic[![Observer-0](assets/images/observer_0.svg)]

???
Building on this concept of strongly seen, we can define the concept of an observer.

The technical definition is: a gossip event that strongly sees interesting gossip events proposed by a supermajority of nodes;

But what it means is that after this gossip event, we know that the information in the graph has been propagated beyond the point of no return and cannot be censored by a malicious actor.

This guarentees consensus on these events; but doesn't define an order.

Let's see an example.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Observer-1](assets/images/observer_1.svg)]

???
Say we want to check whether a2 is an observer. We must check which interesting events this event can strongly see.

It can't strongly see the interesting event created by Alice; so, that's 0/1.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Observer-2](assets/images/observer_2.svg)]

???
It can strongly see Bob's interesting event. We are at 1/2.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Observer-3](assets/images/observer_3.svg)]

???
It can also strongly see Carol's interesting event, which brings us to 2/3.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Observer-4](assets/images/observer_4.svg)]

???
And finally, it can also strongly see Dave's interesting event. So it can strongly see interesting events created by 3 out of 4 nodes.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Observer-5](assets/images/observer_5.svg)]

???
3 out of 4 is a supermajority. a2 is an observer.

---
template:birds_2
## PARSEC
.fitted-pic[![Meta-election-0](assets/images/meta_election_0.svg)]

???
Say that multiple nodes created events that are observers. Each observer strongly sees interesting events created by a supermajority, but they might see different supermajorities. How do we get them to agree which of these interesting events should be the next one?

We do this with a process called meta-election. This process allows the nodes to agree about a single binary value for every node: this value means whether the given node's interesting event should be considered for being the next one or not.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Meta-election-1](assets/images/meta_election_1.svg)]

???
To illustrate, we will follow the process of deciding whether Alice's interesting event will be considered for being the next agreed one.

The process starts with observers, and every observer gets a binary value associated with it. The value says whether this observer can strongly see an interesting event created by the node being the subject of the meta-election.

In our example, Alice's observer can strongly see Alice's interesting event; so can Dave's observer. Bob's and Carol's observers cannot.

Thus, the first estimate is "true" for Alice and Dave, and "false" for Bob and Carol.

Note that the values associated with observers are purely functions of the structure of the graph. No additional data needs to be exchanged - each node can arrive at the same values for every observer independently.

---
template:birds_1
## PARSEC
.fitted-pic[![BV-gossip-0](assets/images/bv_gossip_0.svg)]

???
The first stage of a meta-election is Binary Value Gossip. At this stage every node basically tries to find out what are the estimates of other nodes in order to suggest a possible decision. Let's look at that in detail.

The whole process consists of determining two variables, called "estimates" and "binary values". Both are sets of binary values (so can be empty, contain 0, contain 1 or contain both). The starting point is estimates = {initial vote}, bin-values = empty.

In the picture, estimates are represented by the lower half of the circle, and the binary values by the upper half.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-1](assets/images/bv_gossip_1.svg)]

???
Every event that is a descendant of an observer has its own set of estimates and binary values. The sets are inherited from the self-parent and optionally modified.

A value gets added to estimates if the event sees at least N/3 events with this value in estimates. A value gets added to bin-values if the event sees a supermajority with this value in estimates.

For starters, b1 inherits "false" in estimates from b0. As it sees neither a supermajority of "false", nor N/3 of "true", it stays in this state.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-2](assets/images/bv_gossip_2.svg)]

???
a1 inherits "true" from a0. It sees both b0 and c0, which are more than N/3 and both have "false" in estimates, so it adds "false" to its estimates. Now it can see 3 estimates for "false" (itself, b0 and c0), which causes it to add "false" to bin-values as well.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-3](assets/images/bv_gossip_3.svg)]

???
c1 inherits "false" from c0. It doesn't see anything interesting, so nothing more changes.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-4](assets/images/bv_gossip_4.svg)]

???
b2 inherits a "false" estimate. It sees d0 and a0, though, which constitute more than N/3 for "true", so it adds "true" to estimates. Now it sees 3 estimates for "true", so it ets added to bin-values.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-5](assets/images/bv_gossip_5.svg)]

???
c2 is in a similar boat as b2. It sees both a0 and d0, adds "true" to estimates and then immediately to bin-values.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-6](assets/images/bv_gossip_6.svg)]

???
d1 inherits a "true" estimate. It sees itself, c2 and a0, which are a supermajority of "true", so "true" gets added to bin-values. At the same time, it sees c2 and b1, both having estimates for "false", so it adds "false" to estimates and immediately to bin-values, as d1, c2 and b1 are a supermajority of "false" estimates.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-7](assets/images/bv_gossip_7.svg)]

???
The last analysed event is a2. It inherits values from a1, but it sees a1, b2 and d0 - all of which have "true" in estimates. It adds "true" to bin-values, then.

---
template:birds_1
count: false
## PARSEC
.fitted-pic[![BV-gossip-8](assets/images/bv_gossip_8.svg)]

???
Once an event has non-empty bin-values, it gets assigned an aux value. This aux value is the first value that made it into bin-values. So, a2 has aux=false, while b2, c2 and d1 have aux=true.

Once aux values are determined, progressing requires a coin flip. In PARSEC, we use a concrete coin for simplicity, but it will be easier to explain the algorithm using a proper common coin.

---
template:birds_2
## PARSEC
.fitted-pic[![Common-coin-f-0](assets/images/common_coin_false_0.svg)]

???
The coin is used the following way. Once an event sees a supermajority of auxiliary values (but not just any auxiliary values - they have to be values that are in its own bin-values), it can attempt to decide, but it has to flip a coin first. If it sees a supermajority of auxiliary values that agree with the coin, it decides that value. If it sees a disagreeing supermajority, it starts a new round of consensus and uses the supermajority value as an estimate. If it sees no agreeing supermajority, it starts a new round with a coin value as the estimate.

So let's assume that the bottom events in the graph are now the ones that have some auxiliary values associated with them and there was some more gossip going on later.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Common-coin-f-1](assets/images/common_coin_false_1.svg)]

???
a2 is now an event that sees auxiliary values in a0, b0 and c0. It has both true and false in bin-values, so all of these count. There is no prevailing supermajority, so a2 marks the beginning of a new round with the coin value - false - as an estimate.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Common-coin-f-2](assets/images/common_coin_false_2.svg)]

???
b2, on the other hand, sees b0, c0 and d0, which constitute an agreeing supermajority. This supermajority disagrees with the coin, though, so b2 still cannot decide. It just marks the beginning of a new round with the supermajority value - true - as an estimate.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Common-coin-f-3](assets/images/common_coin_false_3.svg)]

???
c2 also sees b0, c0 and d0. It technically also sees a0, but this doesn't count, since a0 has a false auxiliary value, and c2 doesn't have false in bin-values. Anyway, it does see an agreeing supermajority, so it starts a new round estmating true like b2.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Common-coin-f-4](assets/images/common_coin_false_4.svg)]

???
d1 is in the same situation as c2 and it also starts a new round with an estimate of true.

---
template:birds_1
## PARSEC
.fitted-pic[![Common-coin-t-0](assets/images/common_coin_true_0.svg)]

???
Let's now see what happens in the same situation if the common coin flip results in true.

---
template:birds_1
count:true
## PARSEC
.fitted-pic[![Common-coin-t-1](assets/images/common_coin_true_1.svg)]

???
a1 is in a similar situation as before - it doesn't see an agreeing supermajority, so it uses the coin value as an estimate for the next round.

---
template:birds_1
count:true
## PARSEC
.fitted-pic[![Common-coin-t-2](assets/images/common_coin_true_2.svg)]

???
b2 again sees a supermajority for true. The coin value is also true this time, though, so it is now able to decide true.

---
template:birds_1
count:true
## PARSEC
.fitted-pic[![Common-coin-t-3](assets/images/common_coin_true_3.svg)]

???
c2, like b2, sees an agreeing supermajority and decides.

---
template:birds_1
count:true
## PARSEC
.fitted-pic[![Common-coin-t-4](assets/images/common_coin_true_4.svg)]

???
And so does d1.

---
template:birds
## PARSEC
.fitted-pic[![Signatures](assets/images/meta_vote.jpg)]
???
The last step is to agree on an order for the interesting event.

This is done by holding a virtual election between observers:
Since they strongly see interesting events proposed by a supermajority of nodes, they are said to vote yes for each of these nodes and vote no for all other nodes.

This reduces the larger problem of Byzantine consensus to the problem of Binary consensus: reaching consensus on the outcome of a yes or no question.

---
template:birds_3
## PARSEC
.fitted-pic[![Signatures](assets/images/problem_solved.png)]
???
### Binary consensus
This is a problem that already has an existing elegant solution.

Signature Free Asynchronous Byzantine Consensus with t < n/3 and O(n^2) messages.
Raynal et all.

We took this solution and adapted it to gossip, which wasn't very difficult and allowed us to improve the complexity from O(n^2) to O(n*log(n)).

---
template:birds_2
## PARSEC
.fitted-pic[![Signatures](assets/images/concrete.jpg)]
???
Oh, a little detail: the algorithm we used for Binary consensus depends on a common coin, which is an issue for staying asynchronous when there is churn in the network;

so we replaced that step with a concrete coin, which was published in a paper from Silvio Micali in 2018 named "Byzantine Agreement made Trivial".

---
template:birds
## PARSEC
* Asynchronous ✓ (*)
* Scalable ✓
* Permission-less ✓
* Open Source ✓
* Simple ✓
???
So that's it, we didn't invent gossip, we didn't come up with a solution to binary consensus, we didn't invent the conrete coin.

We simply reduced the general problem of asynchronous byzantine consenus to a binary consensus problem and solved it over gossip for efficiency;
and just like that, we got all the properties we needed :D

We already coded it up in a static network and are now expending it to handle churn.

---
template:small_dots
## What's next?
--
count: false
- Implementation
--
count: false
  - Dynamic membership
???
Ongoing
--
count: false
  - Integration into routing layer
--
count: false
- Paper improvements
--
count: false
  - Incorporate community feedback
--
count: false
  - Improve asynchrony
--
count: false
- Upcoming London events
--
count: false
  - Work On Blockchain (Sept 11)
???
Deep dive at Kings College London
2 hours including grilling/Q&A session
With Bart Kaminski

https://www.eventbrite.com/e/an-exploration-of-the-safe-network-and-its-open-consensus-protocol-parsec-tickets-48908375267
--
count: false
  - Rust London Meetup (End of Sept)
???
For a talk about how the entire rust ecosystem has been supporting us when implementing PARSEC

https://www.meetup.com/Rust-London-User-Group/
--
count: false
  - Mozfest (?) (Oct 26-28)
???
Taking back the web! Set up your first SAFE website in under a minute
https://github.com/MozillaFestival/mozfest-program-2018/issues/221

---
template: the_end
# Thank you!
.center[
.small-pic[![cryptonomy](assets/images/maidsafe_logo.png)]
.small-pic[![cryptonomy](assets/images/cryptonomy.jpg)]
.small-pic[![rise_logo](assets/images/rise_logo)]
]
???
- Thanks to Oscar from cryptonomy for basically organising the entire meetup

- Thanks to Rise for hosting us

- Thank you all for listening
---
.center[
# [Gossip graph](assets/images/Carol-008.dot.svg)
# [Whitepaper](assets/PARSEC.pdf)
]

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'rust',
        highlightLines: 'true',
        highlightSpans: 'true',
        highlightStyle: 'tomorrow-night-blue'});
    </script>
  </body>
</html>
