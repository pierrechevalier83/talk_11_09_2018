<!DOCTYPE html>
<html>
  <head>
    <title>SAFE Network Presentation</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Vollkorn);
      @import url(https://fonts.googleapis.com/css?family=Monaco);
      @font-face {
          font-family: Halis Round;
          font-style: normal;
          font-weight: bold;
          src: url("assets/fonts/HalisR-Bold.otf") format("opentype");
      }
      @font-face {
          font-family: Campton;
          font-style: normal;
          font-weight: 600;
          src: url("assets/fonts/campton-semibold.ttf") format("truetype");
      }
      body {
        font-family: 'Volkorn';
        color: black;
        max-width: 90%;
      }
      h1, h2 {
        font-family: 'Halis Round';
        max-width: 90%;
      }
      h3 {
        font-family: 'Campton';
        max-width: 90%;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Monaco';
        width: 90%;
      }
      .classy_text {
        color: #333333;
        max-width: 90%;
      }
      .white_text {
        color: white;
        max-width: 90%;
      }
      .remark-code-line-highlighted {
         background-color: #373832;
      }
      .remark-code-span-highlighted {
         background-color: #f0572a;
      }
      .fitted-pic img {
        height: auto;
        width: auto;
        max-height: 340px;
        max-width: 80%;
      }
      .small-pic img {
        height: auto;
        width: auto;
        max-height: 100px;
        max-width: 350px;
      }
      .tiny-pic img {
        height: auto;
        width: auto;
        max-height: 35px;
        max-width: 35px;
      }
      .logo img {
        height: auto;
        width: auto;
        max-height: 35px;
        position: absolute;
        top: 8%;
        left: 1.7%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

layout: true
name: title

class:center
.logo.left[![logo](assets/images/logo.svg)]
<br><br><br><br>

---
layout: true
name: textures
background-position: right bottom, 87.5% top, 75% bottom, 62.5% bottom, right top
background-size: 11.1% 85%, 11.1% 15%, 11.1% 33%, 11.1% 6%, 11.1% 15%  
background-repeat: repeat;

---
layout: true
name: textures_2
background-position: right top, 87.5% bottom, 62.5% top, right bottom, 50% top
background-size: 11.1% 56%, 11.1% 44%, 11.1% 16.25%, 11.1% 44%, 11.1% 6%  
background-repeat: repeat;

---
layout: true
name: textures_3
background-repeat: no-repeat
background-position: right top, 87.5% top, 75% bottom, left top, 12.5% bottom
background-size: 11.1% 100%, 11.1% 100%, 11.1% 16%, 11.1% 6%, 22.2% 6% 

---
layout: true
name: yellow
class: classy_text
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]<br>

---
layout: true
name: light_grey
class: classy_text
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]<br>

---
layout: true
name: dark_grey
class: white_text
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: red
class: white_text
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: blue
class: white_text
background-color: #1f3a80
.logo[![logo](assets/images/logo_light.svg)]<br>

---
layout: true
name: sea
class: classy_text
template: textures
background-image: url("assets/images/texture_1.png"), url("assets/images/texture_3.png"), url("assets/images/texture_2.png"), url("assets/images/yellow.png"), url("assets/images/yellow.png")
background-color: #f5f4f2
<br><br><br>

---
layout: true
name: sea_2
class: classy_text
template: textures_2
background-image: url("assets/images/texture_1.png"), url("assets/images/texture_2.png"), url("assets/images/texture_3.png"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds
class: classy_text
template: textures_3
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_1
class: classy_text
template: textures_3
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_2
class: classy_text
template: textures
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/light_grey.svg"), url("assets/images/light_grey.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_3
class: classy_text
template: textures_2
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/white.png"), url("assets/images/white.png")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: birds_4
class: classy_text
template: textures
background-image: url("assets/images/bird_panel_4.svg"), url("assets/images/bird_panel_1.svg"), url("assets/images/bird_panel_2.svg"), url("assets/images/light_grey.svg"), url("assets/images/light_grey.png")
background-color: #ffffff
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout: true
name: fields
class: white_text
template: textures
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/yellow.png"), url("assets/images/light_grey.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_2
class: white_text
template: textures_2
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/red.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_3
class: white_text
template: textures_3
background-image: url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/texture_7.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: fields_4
class: white_text
template: textures
background-image: url("assets/images/texture_7.png"), url("assets/images/texture_5.png"), url("assets/images/texture_6.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #496c7d
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks
class: white_text
template: textures
background-image: url("assets/images/texture_9.png"), url("assets/images/texture_10.png"), url("assets/images/spark-texture-1.jpg"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_2
class: white_text
template: textures_2
background-image: url("assets/images/spark-texture-1.jpg"), url("assets/images/spark-texture-3.jpg"), url("assets/images/texture_10.png"), url("assets/images/yellow.png"), url("assets/images/white.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_3
class: white_text
template: textures_3
background-image: url("assets/images/texture_9.png"), url("assets/images/texture_10.png"), url("assets/images/spark-texture-1.jpg"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:sparks_4
class: white_text
template: textures
background-image: url("assets/images/spark-texture-1.jpg"), url("assets/images/spark-texture-3.jpg"), url("assets/images/texture_10.png"), url("assets/images/light_grey.png"), url("assets/images/yellow.png")
background-color: #f0572a
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout: true
name: art
background-position: bottom right
background-size: 40% 90%
background-repeat: repeat

---
layout:true
name:small_dots
class: white_text
template: art
background-image: url("assets/images/hiw_pattern_1.svg")
background-color: #1f3a80
.logo[![logo](assets/images/logo_light.svg)]
<br><br><br>

---
layout:true
name:ants
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_2.svg")
background-color: #f2e14c
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:stripes
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_3.svg")
background-color: white
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:rain
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_4.svg")
background-color: #f5f4f2
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:rings
class: classy_text
template: art
background-image: url("assets/images/hiw_pattern_5.svg")
background-color: white
.logo[![logo](assets/images/logo.svg)]
<br><br><br>

---
layout:true
name:the_end
class: classy_text
background-position: bottom
background-size: 100% 20%
background-repeat: repeat
background-image: url("assets/images/timeline_pattern_1.svg")
background-color: white
class:center
.logo.left[![logo](assets/images/logo.svg)]
<br><br><br><br>

---
template: sea
# PARSEC:
### It's cool tech, yo!
<br><br><br>
.small-pic[![maidsafe](assets/images/logo.svg)]

--
count: false

???
Thanks Dug! Very nice presentation.

Now that we're all caught up on what the SAFE Network is at a high level and we've got an idea of how different parts fit together, let's deep dive into one of our latest innovations: PARSEC: a Protocol for Asynchronous, Reliable, Secure and Efficient Consensus.

I'm Pierre, I'm in the routing team at MaidSafe, so I'm part of the team that designed and are now implementing PARSEC.

If you're the kind of people who lurk on the forum and you've been following the news from Maidsafe, you may have a vague idea about what PARSEC is.

What I'ld like to do with this presentation is to walk you through the motivations for inventing it and give you a sneek peek into it's mechanics. I'll be happy at the end of this talk if you take away that PARSEC isn't rocket science. It's just cool tech! Yo!

---
template: sea_2

## Agenda
--
count: false
#### Routing
--
count: false
#### The quest for consensus
--
count: false
#### PARSEC
--
count: false
#### What's next?
---
template: sparks

## Routing

The **brain** of the SAFE Network

--
count: false

### What it doesn't do

--
count: false
- Connect computers to form a p2p network
???
- Crust
--
count: false
- Authenticate joining computers
???
- Authenticator
--
count: false
- Encrypt data
???
- Safe crypto
- Self encryption
--
count: false
- Directly handle how data is stored
???
- Vaults
--
count: false
- Provide an API for developing applications 
???
- Safe client libs
--
count: false
- Conform to semantic web standards 
???
- RDF/SOLID integration
--
count: false
- ... 
???
---
template:sparks_2
## Routing

### What it does
--
count: false
- Partitions the network into `sections`
???
- Sharding
- Decides which `nodes` belong in which `sections`
--
count: false
- Assigns a `close group` for each data
???

- Deduplication
- Redundancy
--
count: false
- Mitigates sybil attacks
???

- Node Ageing
- Node rellocation
--
count: false
- Allows secure communications across sections
???

- Secure message relay
--
count: false
- Enables consensus within a section
???

- Quorum of agreeing peers
- Agreement on events and orders
---
template:sparks_3
## Routing

### How it does it
--
count: false

- Pretend everything is a 256 bit int
---
template:sparks_3
count: false
## Routing

### How it does it

- Pretend **everything** is a 256 bit int

--
count: false
 - Computers
--
count: false
 - Data
---
template:sparks_4
## Routing

### How it does it

- Pretend everything is a **256 bit int**
--
count: false

```
Between 0 and 115792089237316195423570985008687907853269984665640564039457584007913129639935
```
???
 - 2<sup>256</sup>-1
 - ~10<sup>77</sup>
 - ~115 quattuorvigintillion
  - ~.1% of the number of atoms in the universe
--
count: false
can be represented in binary

```
0101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001010100100101001101000101010000110101000001000001
```
---
template:sparks
## Routing

### How it does it

- Reduce all problems to simple maths
--
count: false

 - Example: which section should this node join?
```
node id: 11010010001111100...
```
---
template:sparks
count: false
## Routing
### How it does it

 - Example: which section should this node join?
```
node id: 11010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | Right |       |       |
|      |       | 0     |       |       | 1     |       |       |
|      | Left  | Right |       |       | Left  | Right |       |
|      | 00    | 01    |       |       | 10    | 11    |       |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]

---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: `1`1010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | Right |       |
|      | 00    | 01    |       |       | 10    | 11    |       |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]
---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: 1`1`010010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | **Right** |   |
|      | 00    | 01    |       |       | 10    | **11** |      |
| Left | Right | Left  | Right | Left  | Right | Left  | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | 110   | 111   |
]
---
template:sparks
count: false
## Routing

### How it does it

 - Example: which section should this node join?
```
node id: 11`0`10010001111100...
```
.center[
|      |       |       |       |       |       |       |       |
| :--: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|      |       | Left  |       |       | **Right** |   |       |
|      |       | 0     |       |       | **1** |       |       |
|      | Left  | Right |       |       | Left  | **Right** |   |
|      | 00    | 01    |       |       | 10    | **11** |      |
| Left | Right | Left  | Right | Left  | Right | **Left** | Right |
| 000  | 001   | 010   | 011   | 100   | 101   | **110**   | 111   |
]
---
template:sparks_2
## Routing

### How it does it

 - Example: who should store this data?
```
data id: 11010010001111100...
```
--
count: false
.center[The `GROUP_SIZE` closest<br>nodes in xor distance]
???
xor space has the desirable property that distances are unique
---
template:sparks
## Routing

### How it does it

 - Example: how do members of a section agree<br>
   on the order in which things happen?
--
count: false

.center.small-pic[![parsec](assets/images/byzantine_army.jpg)]
???
Byzantine Generals problem
---
template: fields_3
## The quest for consensus
.fitted-pic[![byzantine](assets/images/byzantine_army.jpg)]
???
In 1982, Leslie Lamport et all described the following mathematical problem:

A group of generals of the byzantine army are camped with their troops around an ennemy city. Communicating only by messenger, the generals must agree upon a common battle plan. However, one or more of them may be traitors trying to confuse the others.

The problem is to find an algorithm to ensure that the loyal generals will reach agreement.

This problem seems deceptively simple, but it has been extensively studied in the last 20 years and better and better solutions keep coming up.

---
template: fields_2
## The quest for consensus
### Our needs
<br>
--
count: false

- Asynchronous
???
We're speaking of a real world network hosted on people's computers.
We cannot make assumptions on the time it takes for a node to respond.
--
count: false
- Scalable
???
Optimal complexity: O(N*log(N))
--
count: false
- Permission-less
???
Can support dynamic membership: nodes die
--
count: false
- Open Source
???
GPL-v3
Necessary to fit within our ethos
--
count: false
- Simple
???
Simplicity is a property that is extremely underrated.
If an algorithm is simple, it improves the security of the implementation
as anyone can reason about it and see bugs.

---
template: fields
## The quest for consensus
### State of the art
#### Blockchain (2008)

* ~~Asynchronous~~
* ~~Scalable~~
* Permission-less
* Open Source
* Simple

---
template: fields_3
## The quest for consensus
### State of the art
#### HashGraph (2016)

* Asynchronous (*)
* Scalable
* Permission-less
* ~~Open Source~~
* Simple

---
template: fields_4
## The quest for consensus
### State of the art
#### Honey Badger BFT (2016)

* Asynchronous (*)
* Scalable
* Permission-less (*)
* Open Source
* ~~Simple~~

---
template: fields_2
## The quest for consensus
### State of the art
#### Avalanche (2018)

* ~~Asynchronous~~
* Scalable
* Permission-less
* Open Source
* Simple

---
template: fields
## The quest for consensus
.fitted-pic[![PARSEC](assets/images/falcon.png)]

???
So we came to realize that the state of the art wasn't enough and that we would need to come up with our own solution if we wanted a protocol to fit all our needs.

---
template:birds_2
## PARSEC
.fitted-pic[![PARSEC](assets/images/spoiler_alert.png)]

???
Now, how you solve a complex maths problem is by breaking it down into simpler maths problems and solving these.

Even better if someone else already solved these smaller maths problems for you so you can save some time.

In this section, I'll explain some of these smaller maths problems for the case of consensus.

It's gonna be really boring, so I thought I would reveal the features we gain from this exercise so hopefully that keeps you motivated to listen to my monotone lecture :) 
---
template:birds_2
count: false
## PARSEC
### Features
???
So with PARSEC, we achieved to find a solution to the Byzantine Generals Problem that is:
--
count: false

* Asynchronous ✓ (*)
???
Almost asynchronous:
- Every step of the algorithm is fully asynchronous with one exception: the concrete coin
- In that step, we can't claim we are fully asynchronous as we don't meet the technical theoretical requirements; although in practice, it's very unlikely to make a difference
- The synchrony assumption we have is still less than that of any competing protocol that scales like ours does
- We are currently focused on implementing the algorithm we already have as this is necessary to get the SAFE Network off the ground; but we think we may be able to make that last step fully asynchronous with no asterisque with a little bit more research
--
count: false
* Scalable ✓
???
No compromise: PARSEC can reach consensus in O(N*log(N)) which is at the theoretical limit for the number of nodes.
---
template:birds_2
count: false
## PARSEC
### Features
* Asynchronous ✓ (*)
* Scalable ✓
* Permission-less ✓
???
The algorithm can operate in a completely permission-less setting.
The only requirement is that less than a third of the participants at any time are malicious, which we guarentee in the SAFE Network with a number of Sybil protection measures such as node ageing.
Nodes can join a section and leave it without affecting consensus and without requiring any syncrhonous step.
--
count: false
* Open Source ✓
???
Not only in license, GPL-V3 which is Free software, but also in our ethos.
We have already received 2 contributions to the PARSEC github and feedback on the whitepaper from members of the forum and even from Vlad Zamfir from Ethereum.
--
count: false
* Simple ✓
???
In the litterature, you find all kinds of fancy algorithms to solve the Byzantine Generals Problem or parts of it; and most of them aren't even efficient.
Our algorithm only uses simple ideas and composes them to make an elegant solution.

Not to make it sound like we're some kinds of geniuses: the two most powerful, simple and elegant ideas behind PARSEC are the way we solve binary consensus and the concrete coin idea. Both ideas were shameless-ly ripped off from existing papers :D
---
template:birds
## PARSEC
.fitted-pic[![PARSEC overview](assets/images/parsec_overview.png)]
???
### In a nutshell

Before diving too deep into the details; let's cover PARSEC at a high level:

- Nodes on the network use gossip to communicate with each other.
Gossip is a very efficient way to communicate information in a trustless network.

- As they are gossiping to each other, each node keeps a full record of everything that has been gossiped to them. We call this record the gossip graph.

- The gossip graph is a data structure that is eventually consistent; which means that even though different nodes will build different gossip graphs, at some point nodes will have a proof that something that's in their graph will eventually make it to other nodes' graphs.

- What PARSEC does is infer an order on events that were communicated from the gossip graph

---
template:birds_3
## PARSEC
.fitted-pic[![Gossip](assets/images/gossip.jpg)]
???
### Gossip

Now when I said: nodes gossip to each other, this may seem a bit vague; but it's not.
The gossip protocol is a well known mathematical construct to spread information in distributed systems.

The idea is to spread information in a way that is totally resilient to any node being dishonest but also efficient.

- Broadcast: inefficient
O(N^2)
- Round Robin: not resilient
O(N)
- Gossip: pick partner at random every fixed time interval
O(N*log(N))

---
template:birds_2
## PARSEC
.fitted-pic[![Signatures](assets/images/signature.jpg)]
???
Gossiping information is enough to spread it in a resilient manner, but it's not enough to establish trust or to decide an order in which things happened on the network.

Nodes keep a record of everything that's been gossiped to them and they transmit that to other nodes when they're gossiping to them.

They do this with cryptograpically signed messages, which means that they can be proven to have propagated that version of the truth.

This means that if a node sent you a version of the truth and sent someone else a different version; this node would eventually be caught in their lie.

---
template:birds_2
## PARSEC
.fitted-pic[![Gossip-graph-0](assets/images/gossip_graph_0.svg)]
???
Let's dive in and see what a gossip graph may look like.

We will start by illustrating how a gossip graph may get generated and then we will use it to explain some related concepts.

We start by introducing our players. We have a network with four members, Alice, Bob, Carol and Dave. They start with nothing, but the situation will change soon.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-1](assets/images/gossip_graph_1.svg)]

???
Bob creates his first event (he observed something going on in the network).

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-2](assets/images/gossip_graph_2.svg)]

???
Bob gossips to Carol, which prompts her to create her own event. Note that she doesn't just store her event, but also the one she got from Bob.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-3](assets/images/gossip_graph_3.svg)]

???
Now Bob gossips to Alice, too.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-4](assets/images/gossip_graph_4.svg)]

???
Alice responds to Bob, so Bob creates another event.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-5](assets/images/gossip_graph_5.svg)]

???
In the meantime, Carol gossips to Dave.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-6](assets/images/gossip_graph_6.svg)]

???
...and to Alice.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-7](assets/images/gossip_graph_7.svg)]

???
Dave responds to Carol.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-8](assets/images/gossip_graph_8.svg)]

???
Carol gossips the event created by Dave's response to Bob.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-9](assets/images/gossip_graph_9.svg)]

???
Explain how there is some asynchrony going on - Bob sent gossip to Carol before he received new gossip from her, hence the other-parent is an older event.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-10](assets/images/gossip_graph_10.svg)]

???
Bob sends updated gossip to Alice.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-11](assets/images/gossip_graph_11.svg)]

???
Carol gossips to Dave.

---
template:birds_2
count:false
## PARSEC
.fitted-pic[![Gossip-graph-12](assets/images/gossip_graph_12.svg)]

???
Now let's name all the gossip events. We will call them by the first letter of creator's name and the sequence index, so Alice's events are a0, a1, a2..., Bob's are b0, b1,... etc. (Those are just arbitrary names to focus our attention when we talk about the graph.)

Note that since every time nodes gossip, they actually send everything they have, every node has _exactly_ all the ancestors of its latest event. Since the gossip events contain hashes of their parents, if two nodes have copies of the same single event, they are also guaranteed to have identical copies of all ancestors of this event. We say that their graphs are _consistent_.

By the way, this graph can't be a whole gossip graph stored by a single node, as there is no event that all other events are ancestors of. We should consider this illustration a "God's view", or just a part of a larger graph of a single node that contains some later events.

Also note that some of these gossip events could contain votes, which an observation by a node of something happening in the network. (The first event created by Bob probably does.)

---
template:birds_1
## PARSEC
.fitted-pic[![Seen-0](assets/images/seen_0.svg)]

???
Once we have the gossip graph, we can start talking about its properties. One of the important concept in such a graph is the concept of an event _seeing_ another event.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Seen-1](assets/images/seen_1.svg)]

???
Here is an example. We say that a1 _sees_ c0, because c0 is a1's ancestor. There is a caveat here - if a node was malicious and created a _fork_, and both branches of the fork contain ancestors of our event, then we say that it doesn't see any of them. This is an important protection against malicious behaviour - if you try to game the system, you lose all influence you might have had.

---
template:birds_1
count:false
## PARSEC
.fitted-pic[![Seen-2](assets/images/seen_2.svg)]

???
Another example: c2 sees b0. This is just to showcase that the event being seen doesn't have to be a direct ancestor of the event seeing it.

---
template:birds_3
## PARSEC
.fitted-pic[![Signatures](assets/images/seen_strongly_seen_2.png)]
???
To be able to analyse these gossip graphs, it is useful to define a couple of relationships between events.

This graph demonstrates the concept of seeing.

A more recent gossip event (like d_4 here) is said to see an older gossip event (for instance b_0) if b_0 is an ancestor of d_4. So you can trace a path in the graph that goes from b_0 to d_4, only going upwards.

Note that the history from each node's point of view must be linear. If it isn't, it's called a fork and it proves that the author of the forked events is malicious.

In that case, not only will the node be punished, but also none of the branches of the forks will be seen by any gossip event that descends from both.

---
template:birds_3
## PARSEC
.fitted-pic[![Signatures](assets/images/seen_strongly_seen_3.png)]
???
Another crucial concept when analysing the gossip graph is that of strongly seeing.

A gossip event strongly sees another gossip event if it can see it and the directed paths between both events cover over 2/3 of the nodes.

For instance here, Alice's event: a_1 sees b_0 and the paths between a_1 and b_0 cover events created by Alice, Bob and Dave.

This definition is very important because it represents the point of no return after which a rumour is unstopable by any malicious nodes.

The reason we only require over 2/3 of the nodes (a supermajority) and not all nodes is so that 1/3 - 1 nodes can be malicious and completely stop participating in the gossip protocol without ever affecting progress.

---
template:birds
## PARSEC
.fitted-pic[![Signatures](assets/images/interesting_event.jpg)]
???
Now, as I mentionned when describing gossip, some of the events contain votes from nodes.

For instance Alice may learn that Eric would like to join the network and then vote for this.

We could reach consensus on the order of which one of these votes, and that would totally work; but for us, in the SAFE Network, we only care about votes that have reached quorum.

So we define the concept of an interesting event which is a **gossip event** which **sees** **gossip events** created by a **supermajority** of **nodes** that contain **votes** for a given **network event**.

We will only reach consensus on these as they're the only interesting events for us.

---
template:birds_2
## PARSEC
.fitted-pic[![Signatures](assets/images/observer.png)]
???
Building on this concept of strongly seen, we can define the concept of an observer.

The technical definition is: a gossip event that strongly sees interesting gossip events proposed by a supermajority of nodes;

But what it means is that after this gossip event, we know that the information in the graph has been propagated beyond the point of no return and cannot be censored by a malicious actor.

This guarentees consensus on these events; but doesn't define an order.

---
template:birds
## PARSEC
.fitted-pic[![Signatures](assets/images/meta_vote.jpg)]
???
The last step is to agree on an order for the interesting event.

This is done by holding a virtual election between observers:
Since they strongly see interesting events proposed by a supermajority of nodes, they are said to vote yes for each of these nodes and vote no for all other nodes.

This reduces the larger problem of Byzantine consensus to the problem of Binary consensus: reaching consensus on the outcome of a yes or no question.

---
template:birds_3
## PARSEC
.fitted-pic[![Signatures](assets/images/problem_solved.png)]
???
### Binary consensus
This is a problem that already has an existing elegant solution.

Signature Free Asynchronous Byzantine Consensus with t < n/3 and O(n^2) messages.
Raynal et all.

We took this solution and adapted it to gossip, which wasn't very difficult and allowed us to improve the complexity from O(n^2) to O(n*log(n)).

---
template:birds_2
## PARSEC
.fitted-pic[![Signatures](assets/images/concrete.jpg)]
???
Oh, a little detail: the algorithm we used for Binary consensus depends on a common coin, which is an issue for staying asynchronous when there is churn in the network;

so we replaced that step with a concrete coin, which was published in a paper from Silvio Micali in 2018 named "Byzantine Agreement made Trivial".

---
template:birds
## PARSEC
* Asynchronous ✓ (*)
* Scalable ✓
* Permission-less ✓
* Open Source ✓
* Simple ✓
???
So that's it, we didn't invent gossip, we didn't come up with a solution to binary consensus, we didn't invent the conrete coin.

We simply reduced the general problem of asynchronous byzantine consenus to a binary consensus problem and solved it over gossip for efficiency;
and just like that, we got all the properties we needed :D

We already coded it up in a static network and are now expending it to handle churn.

---
template:small_dots
## What's next?
--
count: false
- Implementation
--
count: false
  - Dynamic membership
???
Ongoing
--
count: false
  - Integration into routing layer
--
count: false
- Paper improvements
--
count: false
  - Incorporate community feedback
--
count: false
  - Improve asynchrony
--
count: false
- Upcoming London events
--
count: false
  - Work On Blockchain (Sept 11)
???
Deep dive at Kings College London
2 hours including grilling/Q&A session
With Bart Kaminski

https://www.eventbrite.com/e/an-exploration-of-the-safe-network-and-its-open-consensus-protocol-parsec-tickets-48908375267
--
count: false
  - Rust London Meetup (End of Sept)
???
For a talk about how the entire rust ecosystem has been supporting us when implementing PARSEC

https://www.meetup.com/Rust-London-User-Group/
--
count: false
  - Mozfest (?) (Oct 26-28)
???
Taking back the web! Set up your first SAFE website in under a minute
https://github.com/MozillaFestival/mozfest-program-2018/issues/221

---
template: the_end
# Thank you!
.center[
.small-pic[![cryptonomy](assets/images/maidsafe_logo.png)]
.small-pic[![cryptonomy](assets/images/cryptonomy.jpg)]
.small-pic[![rise_logo](assets/images/rise_logo)]
]
???
- Thanks to Oscar from cryptonomy for basically organising the entire meetup

- Thanks to Rise for hosting us

- Thank you all for listening
---
.center[
# [Gossip graph](assets/images/Carol-008.dot.svg)
# [Whitepaper](assets/PARSEC.pdf)
]

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLanguage: 'rust',
        highlightLines: 'true',
        highlightSpans: 'true',
        highlightStyle: 'tomorrow-night-blue'});
    </script>
  </body>
</html>
